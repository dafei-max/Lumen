<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UNVEIL PROJECTS - Isometric Stream</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap');
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #fcfcfc;
            font-family: 'Inter', sans-serif;
            user-select: none;
        }
        .ui-top {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            gap: 1px;
            z-index: 10;
        }
        .nav-item {
            border: 1px solid #e0e0e0;
            padding: 10px 20px;
            font-size: 12px;
            letter-spacing: 1px;
            color: #333;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(5px);
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .nav-item:first-child {
            font-weight: 600;
            background: #f5f5f5;
        }
        .nav-item:hover {
            background: #fff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .ui-bottom {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 0;
            z-index: 10;
        }
        
        .scroll-hint {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #999;
            animation: bounce 2s infinite;
            pointer-events: none;
        }
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {transform: translateX(-50%) translateY(0);}
            40% {transform: translateX(-50%) translateY(-10px);}
            60% {transform: translateX(-50%) translateY(-5px);}
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
    </style>
</head>
<body>
    <div class="ui-top">
        <div class="nav-item">UNVEIL ® PROJECTS</div>
        <div class="nav-item">RESEARCH</div>
        <div class="nav-item">STUDIO</div>
        <div class="nav-item">CONTACT</div>
    </div>
    <div class="scroll-hint">SCROLL TO EXPLORE</div>
    <div class="ui-bottom">
        <div class="nav-item">OVERVIEW</div>
        <div class="nav-item">INDEX</div>
    </div>
    <div id="canvas-container"></div>
    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';

        const images = [
            '1040g3g831ptabn7s3u06ecddp46hec0l70ino0o.jpg',
            '1040g3g831ptabn7s3u0mecddp46hec0lcti2ht8.jpg',
            '1040g3g831ptabn7s3u16ecddp46hec0lmsa2d28.jpg',
            '1040g3g831ptabn7s3u1mecddp46hec0l10jk180.jpg',
            '1040g3g831ptabn7s3u26ecddp46hec0l3k8uv7g.jpg',
            '1040g3g831ptabn7s3u2mecddp46hec0le5esup0.jpg',
            '1040g3g831ptabn7s3u36ecddp46hec0lsi4jvm8.jpg',
            '1040g3g831ptabn7s3u3mecddp46hec0lul9argo.jpg',
            '1040g3g831ptabn7s3u46ecddp46hec0l8bpvrfg.jpg'
        ];

        // --- 配置参数 ---
        const CONFIG = {
            cardCount: images.length,
            cardWidth: 3.8,
            cardHeight: 4.8,
            gap: 2.2,
            scrollSpeed: 0.05,
            axisVector: new THREE.Vector3(0, 0, -1),
            hoverStrength: 0.5, // 卡片抽出的比例 (0.5 = 半个宽度)
            hoverLerp: 0.1      // 动画平滑度 (越小越慢)
        };

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xfcfcfc); 
        scene.fog = new THREE.Fog(0xfcfcfc, 5, 40); 

        // --- 正交相机设置 ---
        const frustumSize = 10; 
        const aspect = window.innerWidth / window.innerHeight;
        
        const camera = new THREE.OrthographicCamera(
            frustumSize * aspect / -2,
            frustumSize * aspect / 2,
            frustumSize / 2,
            frustumSize / -2,
            1,
            1000
        );
        camera.position.set(20, 20, 20);
        camera.lookAt(0, 0, 0);
        camera.zoom = 1.0; 
        camera.updateProjectionMatrix();

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.physicallyCorrectLights = true;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // --- 灯光 ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
        dirLight.position.set(10, 20, 5); 
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.bias = -0.0001;
        const shadowSize = 20;
        dirLight.shadow.camera.left = -shadowSize;
        dirLight.shadow.camera.right = shadowSize;
        dirLight.shadow.camera.top = shadowSize;
        dirLight.shadow.camera.bottom = -shadowSize;
        scene.add(dirLight);
        
        const bottomLight = new THREE.DirectionalLight(0xebebeb, 0.5);
        bottomLight.position.set(-5, -10, -5);
        scene.add(bottomLight);

        // --- 纹理加载与适配 ---
        const loader = new THREE.TextureLoader();

        function fitTextureToCard(texture) {
            if (!texture.image) return;
            const imageAspect = texture.image.width / texture.image.height;
            const cardAspect = CONFIG.cardWidth / CONFIG.cardHeight;

            texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
            texture.center.set(0.5, 0.5);

            if (imageAspect > cardAspect) {
                const scale = cardAspect / imageAspect;
                texture.repeat.set(scale, 1);
                texture.offset.set((1 - scale) / 2, 0);
            } else {
                const scale = imageAspect / cardAspect;
                texture.repeat.set(1, scale);
                texture.offset.set(0, (1 - scale) / 2);
            }

            texture.needsUpdate = true;
        }

        // --- 创建卡片组 ---
        const cardsGroup = new THREE.Group();
        scene.add(cardsGroup);
        const cardMeshes = [];
        const geometry = new THREE.PlaneGeometry(CONFIG.cardWidth, CONFIG.cardHeight);

        for (let i = 0; i < CONFIG.cardCount; i++) {
            const material = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0.1,
                roughness: 0.35,
                transmission: 0.1,
                transparent: true,
                opacity: 1.0,
                side: THREE.DoubleSide,
                clearcoat: 1.0,
                clearcoatRoughness: 0.1,
            });
            const texture = loader.load(`image/${images[i]}`, (loadedTexture) => {
                loadedTexture.colorSpace = THREE.SRGBColorSpace;
                fitTextureToCard(loadedTexture);
            });
            const contentMaterial = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                opacity: 0.95
            });
            const contentMesh = new THREE.Mesh(geometry, contentMaterial);
            contentMesh.position.z = -0.05;
            
            const glassMesh = new THREE.Mesh(geometry, material);
            glassMesh.add(contentMesh);
            glassMesh.castShadow = true;
            glassMesh.receiveShadow = true;
            
            // 基础位置
            const zPos = -i * CONFIG.gap;
            const xPos = 0;
            
            glassMesh.position.set(xPos, 0, zPos);
            glassMesh.rotation.y = Math.PI / 4; 
            
            // [新增] 初始化自定义数据，用于动画
            glassMesh.userData = {
                originalZ: zPos,
                originalX: xPos,
                hoverOffset: 0
            };

            cardsGroup.add(glassMesh);
            cardMeshes.push(glassMesh);
        }

        // --- 装饰物 ---
        const mascotGroup = new THREE.Group();
        const mascotGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const mascotMat = new THREE.MeshStandardMaterial({ color: 0x64B5F6 });
        const mascot = new THREE.Mesh(mascotGeo, mascotMat);
        mascot.castShadow = true;
        mascotGroup.add(mascot);
        const lastIndex = CONFIG.cardCount;
        mascotGroup.position.set(0.5, 0.5, -lastIndex * CONFIG.gap - 1);
        mascotGroup.rotation.y = Math.PI / 4;
        cardsGroup.add(mascotGroup);

        // --- 交互逻辑 (Scroll & Hover) ---
        let scrollProgress = 0;
        let targetScrollProgress = 0;

        // [新增] 射线检测相关变量
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2(9999, 9999); // 初始值在屏幕外
        let hoveredObject = null;

        window.addEventListener('wheel', (e) => {
            targetScrollProgress += e.deltaY * 0.002;
        });
        
        let touchStartY = 0;
        window.addEventListener('touchstart', e => touchStartY = e.touches[0].clientY);
        window.addEventListener('touchmove', e => {
            const touchY = e.touches[0].clientY;
            targetScrollProgress += (touchStartY - touchY) * 0.005;
            touchStartY = touchY;
        });

        // [新增] 鼠标移动监听
        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            
            // 1. 滚动逻辑
            scrollProgress += (targetScrollProgress - scrollProgress) * 0.08;
            const maxScroll = CONFIG.cardCount * 0.8; 
            if (scrollProgress < -1) {
                targetScrollProgress += (-1 - targetScrollProgress) * 0.1;
            } else if (scrollProgress > maxScroll) {
                targetScrollProgress += (maxScroll - targetScrollProgress) * 0.1;
            }
            
            const moveVector = new THREE.Vector3(0, 0, 1);
            const distance = scrollProgress * CONFIG.gap;
            cardsGroup.position.copy(moveVector.multiplyScalar(distance));

            // 2. [新增] 射线检测逻辑
            raycaster.setFromCamera(mouse, camera);
            // 递归检测 cardsGroup 的所有子元素
            const intersects = raycaster.intersectObjects(cardsGroup.children, true);
            
            hoveredObject = null;
            if (intersects.length > 0) {
                // 向上查找到最顶层的卡片 Mesh (glassMesh)
                let obj = intersects[0].object;
                while(obj.parent && obj.parent !== cardsGroup) {
                    obj = obj.parent;
                }
                // 排除 mascotGroup，只处理卡片
                if (cardMeshes.includes(obj)) {
                    hoveredObject = obj;
                }
            }

            // 3. 卡片动画 (浮动 + Hover 抽出)
            cardMeshes.forEach((mesh, index) => {
                // A. 基础上下浮动
                mesh.position.y = Math.sin(time * 1.5 + index) * 0.15;

                // B. Hover 抽出逻辑
                const isHovered = (mesh === hoveredObject);
                const targetOffset = isHovered ? CONFIG.cardWidth * CONFIG.hoverStrength : 0;
                
                // 平滑过渡 (Lerp)
                mesh.userData.hoverOffset += (targetOffset - mesh.userData.hoverOffset) * CONFIG.hoverLerp;

                // 计算位移: 
                // 卡片旋转了 45度 (PI/4)。要让它沿自身的 X 轴向右滑出，
                // 我们需要同时改变世界坐标的 X 和 Z。
                // deltaX = offset * cos(45deg)
                // deltaZ = offset * -sin(45deg) (因为旋转让局部X轴指向负Z方向)
                
                const angle = Math.PI / 4;
                const offsetX = mesh.userData.hoverOffset * Math.cos(angle);
                const offsetZ = mesh.userData.hoverOffset * -Math.sin(angle);

                mesh.position.x = mesh.userData.originalX + offsetX;
                // 注意：这里是在原有Z位置基础上做偏移
                mesh.position.z = mesh.userData.originalZ + offsetZ; 
            });
            
            // 装饰物旋转
            mascot.rotation.x = time;
            mascot.rotation.z = time * 0.5;
            mascotGroup.position.y = 0.5 + Math.sin(time * 2) * 0.2;
            
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -frustumSize * aspect / 2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = -frustumSize / 2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>